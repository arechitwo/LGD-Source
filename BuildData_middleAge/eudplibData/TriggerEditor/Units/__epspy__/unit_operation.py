## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *
from eudplib.core.eudfunc import EUDTraceLog, EUDTracedFunc, EUDTracedTypedFunc, EUDTracedMethod, EUDTracedTypedMethod
from eudplib.epscript.helper import _RELIMP, _TYGV, _TYSV, _TYLV, _CGFW, _ARR, _VARR, _SRET, _SV, _ATTW, _ARRW, _ATTC, _ARRC, _L2V, _LSH, _ALL
# (Line 1) import Units.skill_operation as skill;
from Units import skill_operation as skill
# (Line 3) const buildingNexus_ = EUDVArray(8)();
buildingNexus_ = _CGFW(lambda: [EUDVArray(8)()], 1)[0]
# (Line 4) const nexusState_ = EUDArray(8); // 0: 없음, 1: 건설중, 2: 완료
nexusState_ = _CGFW(lambda: [EUDArray(8)], 1)[0]
# (Line 5) const guardNexus_ = EUDVArray(8)();
guardNexus_ = _CGFW(lambda: [EUDVArray(8)()], 1)[0]
# (Line 7) function newNexusFunc(epd){
@EUDFunc
def f_newNexusFunc(epd):
    # (Line 8) setcurpl(epd + 19);
    f_setcurpl(epd + 19)
    # (Line 9) const cp = bread_cp(0, 0);
    cp = f_bread_cp(0, 0)
    # (Line 10) if(buildingNexus_[cp] == 0){
    if EUDIf()(_ARRC(buildingNexus_, cp) == 0):
        # (Line 11) buildingNexus_[cp] = epd;
        _ARRW(buildingNexus_, cp) << (epd)
        # (Line 12) nexusState_[cp] = 1;
        _ARRW(nexusState_, cp) << (1)
        # (Line 13) return true;
        EUDReturn(True)
        # (Line 14) }
        # (Line 15) else{
    if EUDElse()():
        # (Line 16) SetDeathsX(CurrentPlayer, SetTo, 0, 0, 0XFF00);
        # (Line 17) setcurpl(cp);
        DoActions(SetDeathsX(CurrentPlayer, SetTo, 0, 0, 0XFF00))
        f_setcurpl(cp)
        # (Line 18) SetResources(CurrentPlayer, Add, 300, 0);
        # (Line 19) eprintf("이미 수도를 보유중입니다.");
        DoActions(SetResources(CurrentPlayer, Add, 300, 0))
        f_eprintf("이미 수도를 보유중입니다.")
        # (Line 20) return false;
        EUDReturn(False)
        # (Line 21) }
        # (Line 22) return false;
    EUDEndIf()
    EUDReturn(False)
    # (Line 23) }
    # (Line 25) function checkNexusDie(cp, unit : CUnit){

@EUDTypedFunc([None, CUnit])
def f_checkNexusDie(cp, unit):
    # (Line 26) if(unit.orderID != 0) return;
    if EUDIf()(_ATTC(unit, 'orderID') == 0, neg=True):
        EUDReturn()
        # (Line 27) if(unit.unitType == "수도 건설중" ){
    EUDEndIf()
    if EUDIf()(_ATTC(unit, 'unitType') == "수도 건설중"):
        # (Line 28) buildingNexus_[cp] = 0;
        _ARRW(buildingNexus_, cp) << (0)
        # (Line 29) nexusState_[cp] = 0; // 상태 초기화
        _ARRW(nexusState_, cp) << (0)
        # (Line 30) eprintf("수도가 파괴되었습니다.");
        f_eprintf("수도가 파괴되었습니다.")
        # (Line 32) }
        # (Line 33) else if(unit.unitType == "수도"){
    if EUDElseIf()(_ATTC(unit, 'unitType') == "수도"):
        # (Line 34) const deleteguardNexusUnit = CUnit(guardNexus_[cp]);
        deleteguardNexusUnit = CUnit(guardNexus_[cp])
        # (Line 35) deleteguardNexusUnit.die();
        deleteguardNexusUnit.die()
        # (Line 36) buildingNexus_[cp] = 0;
        _ARRW(buildingNexus_, cp) << (0)
        # (Line 37) nexusState_[cp] = 0; // 상태 초기화
        _ARRW(nexusState_, cp) << (0)
        # (Line 38) eprintf("수도가 파괴되었습니다.");
        f_eprintf("수도가 파괴되었습니다.")
        # (Line 39) }
        # (Line 40) }
    EUDEndIf()
    # (Line 42) function handleNexus(cp){

@EUDFunc
def f_handleNexus(cp):
    # (Line 43) const unit = CUnit(buildingNexus_[cp]);
    unit = CUnit(buildingNexus_[cp])
    # (Line 44) if (!unit) return;
    if EUDIf()(unit, neg=True):
        EUDReturn()
        # (Line 47) if (nexusState_[cp] == 1) {
    EUDEndIf()
    if EUDIf()(_ARRC(nexusState_, cp) == 1):
        # (Line 48) if (unit.unitType == "수도 건설중" && unit.orderID == 23) {
        if EUDIf()(EUDSCAnd()(_ATTC(unit, 'unitType') == "수도 건설중")(_ATTC(unit, 'orderID') == 23)()):
            # (Line 49) unit.setloc($L("Transpos1") + cp);
            unit.setloc(EncodeLocation("Transpos1") + cp)
            # (Line 50) unit.remove();
            unit.remove()
            # (Line 51) nexusState_[cp] = 3; // 임시 상태: 삭제됨, 다음 프레임에서 생성 예정
            _ARRW(nexusState_, cp) << (3)
            # (Line 52) return;
            EUDReturn()
            # (Line 53) }
            # (Line 54) checkNexusDie(cp, unit);
        EUDEndIf()
        f_checkNexusDie(cp, unit)
        # (Line 56) }
        # (Line 58) else if (nexusState_[cp] == 3) {
    if EUDElseIf()(_ARRC(nexusState_, cp) == 3):
        # (Line 59) const realNexus = CUnit.from_next();
        realNexus = CUnit.from_next()
        # (Line 60) CreateUnit(1, "수도", $L("Transpos1") + cp, cp);
        # (Line 61) buildingNexus_[cp] = realNexus;
        DoActions(CreateUnit(1, "수도", EncodeLocation("Transpos1") + cp, cp))
        _ARRW(buildingNexus_, cp) << (realNexus)
        # (Line 62) nexusState_[cp] = 2; // 완료 상태로 변경
        _ARRW(nexusState_, cp) << (2)
        # (Line 65) const guardNexusUnit = CUnit.from_next();
        guardNexusUnit = CUnit.from_next()
        # (Line 66) CreateUnit(1, 29, $L("Transpos1") + cp, cp);
        # (Line 67) guardNexusUnit.statusFlags.Invincible = true;
        DoActions(CreateUnit(1, 29, EncodeLocation("Transpos1") + cp, cp))
        _ATTW(guardNexusUnit.statusFlags, 'Invincible') << (True)
        # (Line 68) guardNexus_[cp] = guardNexusUnit;
        _ARRW(guardNexus_, cp) << (guardNexusUnit)
        # (Line 69) return;
        EUDReturn()
        # (Line 70) }
        # (Line 71) if(nexusState_[cp] == 2){
    EUDEndIf()
    if EUDIf()(_ARRC(nexusState_, cp) == 2):
        # (Line 72) checkNexusDie(cp, unit);
        f_checkNexusDie(cp, unit)
        # (Line 73) }
        # (Line 74) }
    EUDEndIf()
    # (Line 76) function newUnitLoop(){

@EUDFunc
def f_newUnitLoop():
    # (Line 77) foreach(ptr, epd : EUDLoopNewUnit(20)){
    for ptr, epd in EUDLoopNewUnit(20):
        # (Line 78) epdswitch(epd + 25,0xFF){
        EPDSwitch(epd + 25, 0xFF)
        # (Line 79) case $U("수도 건설중"):
        _t1 = EUDSwitchCase()
        # (Line 80) newNexusFunc(epd);
        if _t1(EncodeUnit("수도 건설중")):
            f_newNexusFunc(epd)
            # (Line 81) break;
            EUDBreak()
            # (Line 82) case 168:
        _t2 = EUDSwitchCase()
        # (Line 84) break;
        if _t2(168):
            EUDBreak()
            # (Line 85) case 156:
        _t3 = EUDSwitchCase()
        # (Line 86) skill.newCity(epd);
        if _t3(156):
            skill.f_newCity(epd)
            # (Line 87) break;
            EUDBreak()
            # (Line 88) }
        # (Line 90) }
        EUDEndSwitch()
        # (Line 92) }

    # (Line 95) function getClickedUnitEPD(player : TrgPlayer){

@EUDTypedFunc([TrgPlayer])
def f_getClickedUnitEPD(player):
    # (Line 96) const clickedArrayEPD = EUDVArray(8)();
    clickedArrayEPD = EUDVArray(8)()
    # (Line 97) const CLICKED_UNIT_OFFESET = EPD(0x6284E8); // 클릭한 유닛의 포인터 주소
    CLICKED_UNIT_OFFESET = EPD(0x6284E8)
    # (Line 98) if (!MemoryEPD(CLICKED_UNIT_OFFESET + 12*player, Exactly, clickedArrayEPD[player])
    _t1 = EUDIf()
    # (Line 99) && !MemoryEPD(CLICKED_UNIT_OFFESET + 12*player, Exactly, 0)) {
    if _t1(EUDSCAnd()(MemoryEPD(CLICKED_UNIT_OFFESET + 12 * player, Exactly, clickedArrayEPD[player]), neg=True)(MemoryEPD(CLICKED_UNIT_OFFESET + 12 * player, Exactly, 0), neg=True)()):
        # (Line 100) clickedArrayEPD[player] = cunitepdread_epd(CLICKED_UNIT_OFFESET + 12*player)[[1]];
        _ARRW(clickedArrayEPD, player) << (f_cunitepdread_epd(CLICKED_UNIT_OFFESET + 12 * player)[1])
        # (Line 101) }
        # (Line 102) return clickedArrayEPD[player];
    EUDEndIf()
    EUDReturn(clickedArrayEPD[player])
    # (Line 103) }
    # (Line 108) function logClickedUnit(player){

@EUDFunc
def f_logClickedUnit(player):
    # (Line 110) const unit = CUnit(getClickedUnitEPD(player));
    unit = CUnit(f_getClickedUnitEPD(player))
    # (Line 111) const orderId = bread_epd(unit + 0x4C/4, 1);
    orderId = f_bread_epd(unit + 0x4C // 4, 1)
    # (Line 112) const secondaryOrderId = unit.secondaryOrderID;
    secondaryOrderId = unit.secondaryOrderID
    # (Line 113) const unitType = unit.unitType;
    unitType = unit.unitType
    # (Line 114) setcurpl(unit + 0x98/4);
    f_setcurpl(unit + 0x98 // 4)
    # (Line 115) const buildQ1 = wread_cp(0, 0);
    buildQ1 = f_wread_cp(0, 0)
    # (Line 116) const buildQ2 = wread_cp(0, 2);
    buildQ2 = f_wread_cp(0, 2)
    # (Line 117) const buildQ3 = wread_cp(1, 0);
    buildQ3 = f_wread_cp(1, 0)
    # (Line 118) const buildQ4 = wread_cp(1, 2);
    buildQ4 = f_wread_cp(1, 2)
    # (Line 119) const buildQ5 = wread_cp(2, 0);
    buildQ5 = f_wread_cp(2, 0)
    # (Line 120) setcurpl(unit + 0xEC/4);
    f_setcurpl(unit + 0xEC // 4)
    # (Line 121) const buildEPD = cunitepdread_cp(0)[[1]];
    buildEPD = f_cunitepdread_cp(0)[1]
    # (Line 122) const buildingUnit = CUnit(buildEPD);
    buildingUnit = CUnit(buildEPD)
    # (Line 123) const remainingBuildTime = wread_epd(buildingUnit + 0xAC/4, 0);
    remainingBuildTime = f_wread_epd(buildingUnit + 0xAC // 4, 0)
    # (Line 124) setcurpl(player);
    f_setcurpl(player)
    # (Line 126) const s = StringBuffer(1024);
    s = StringBuffer(1024)
    # (Line 127) const txtptr = gettextptr();  // 채팅 포인터 값 가져오기 (채팅보존 출력용)
    txtptr = f_gettextptr()
    # (Line 128) s.insert(0);
    s.insert(0)
    # (Line 129) s.appendf("\x04최근 클릭한 유닛 \x02종류=:{} \x07오더=:{} \x07state=:{} \x07s오더=:{} \n", unitType, orderId, unit.orderState, secondaryOrderId);
    s.appendf("\x04최근 클릭한 유닛 \x02종류=:{} \x07오더=:{} \x07state=:{} \x07s오더=:{} \n", unitType, orderId, unit.orderState, secondaryOrderId)
    # (Line 130) s.appendf("\x04 현재 position=:{} \x07 target position=:{} \n", unit.pos, unit.orderTargetPos);
    s.appendf("\x04 현재 position=:{} \x07 target position=:{} \n", unit.pos, unit.orderTargetPos)
    # (Line 131) s.appendf("\x04 move position=:{} \n", unit.moveTargetPos);
    s.appendf("\x04 move position=:{} \n", unit.moveTargetPos)
    # (Line 132) s.appendf("\x04빌드1=:{} \x07빌드2=:{} \x04빌드3=:{} \x04빌드4=:{} \x07빌드5=:{}\n", buildQ1, buildQ2, buildQ3, buildQ4, buildQ5);
    s.appendf("\x04빌드1=:{} \x07빌드2=:{} \x04빌드3=:{} \x04빌드4=:{} \x07빌드5=:{}\n", buildQ1, buildQ2, buildQ3, buildQ4, buildQ5)
    # (Line 133) s.appendf("\x04ptr=:{}", remainingBuildTime);
    s.appendf("\x04ptr=:{}", remainingBuildTime)
    # (Line 134) s.Display();
    s.Display()
    # (Line 135) dwwrite(0x640B58, txtptr);
    f_dwwrite(0x640B58, txtptr)
    # (Line 136) }
    # (Line 138) function clickedBuildingCommand(cp){

@EUDFunc
def f_clickedBuildingCommand(cp):
    # (Line 139) const clickedCUnit = CUnit(getClickedUnitEPD(cp));
    clickedCUnit = CUnit(f_getClickedUnitEPD(cp))
    # (Line 140) if (!clickedCUnit) return;
    if EUDIf()(clickedCUnit, neg=True):
        EUDReturn()
        # (Line 141) logClickedUnit(cp);
    EUDEndIf()
    f_logClickedUnit(cp)
    # (Line 143) if(clickedCUnit.unitType == "수도"){
    if EUDIf()(_ATTC(clickedCUnit, 'unitType') == "수도"):
        # (Line 144) skill.buildFromCapital(cp, clickedCUnit);
        skill.f_buildFromCapital(cp, clickedCUnit)
        # (Line 145) }
        # (Line 147) }
    EUDEndIf()
    # (Line 149) function playerLoop(){

@EUDFunc
def f_playerLoop():
    # (Line 150) foreach(cp: EUDLoopPlayer(None)){
    for cp in EUDLoopPlayer(None):
        # (Line 151) setcurpl(cp);
        f_setcurpl(cp)
        # (Line 152) handleNexus(cp);
        f_handleNexus(cp)
        # (Line 153) clickedBuildingCommand(cp);
        f_clickedBuildingCommand(cp)
        # (Line 154) }
        # (Line 155) }

    # (Line 157) function mainLoop(){

@EUDFunc
def f_mainLoop():
    # (Line 158) newUnitLoop();
    f_newUnitLoop()
    # (Line 159) playerLoop();
    f_playerLoop()
    # (Line 160) skill.run();
    skill.f_run()
    # (Line 161) skill.exit();
    skill.f_exit()
    # (Line 163) }
