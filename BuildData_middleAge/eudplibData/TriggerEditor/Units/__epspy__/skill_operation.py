## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *
from eudplib.core.eudfunc import EUDTraceLog, EUDTracedFunc, EUDTracedTypedFunc, EUDTracedMethod, EUDTracedTypedMethod
from eudplib.epscript.helper import _RELIMP, _TYGV, _TYSV, _TYLV, _CGFW, _ARR, _VARR, _SRET, _SV, _ATTW, _ARRW, _ATTC, _ARRC, _L2V, _LSH, _ALL
# (Line 1) const tempUnitGroup = UnitGroup(1700);
tempUnitGroup = _CGFW(lambda: [UnitGroup(1700)], 1)[0]
# (Line 3) function useCapitalSkill(player : TrgPlayer, unit : CUnit){
@EUDTypedFunc([TrgPlayer, CUnit])
def f_useCapitalSkill(player, unit):
    # (Line 4) const orderId          = unit.orderID;
    orderId = unit.orderID
    # (Line 6) if (orderId != 31 || orderId != 30) return;// 건설 명령이 아닐 경우 리턴
    if EUDIf()(EUDSCOr()(orderId == 31, neg=True)(orderId == 30, neg=True)()):
        EUDReturn()
        # (Line 9) const orderState       = unit.orderState;
    EUDEndIf()
    orderState = unit.orderState
    # (Line 10) const posX             = unit.posX;
    posX = unit.posX
    # (Line 11) const posY             = unit.posY;
    posY = unit.posY
    # (Line 12) const targetX          = unit.orderTargetX;
    targetX = unit.orderTargetX
    # (Line 13) const targetY          = unit.orderTargetY;
    targetY = unit.orderTargetY
    # (Line 14) const buildQ           = unit.buildQueue1;
    buildQ = unit.buildQueue1
    # (Line 15) const buildMaxRange    = 15 * 32;
    buildMaxRange = 15 * 32
    # (Line 16) const buildMinRange    = 10 * 32;
    buildMinRange = 10 * 32
    # (Line 19) const dx = posX - targetX;
    dx = posX - targetX
    # (Line 20) const dy = posY - targetY;
    dy = posY - targetY
    # (Line 21) dx.iabs();
    dx.iabs()
    # (Line 22) dy.iabs();
    dy.iabs()
    # (Line 23) if (dx * dx + dy * dy > buildMaxRange * buildMaxRange) {
    if EUDIf()(dx * dx + dy * dy <= buildMaxRange * buildMaxRange, neg=True):
        # (Line 24) eprintf("건설 위치가 너무 멉니다.");
        f_eprintf("건설 위치가 너무 멉니다.")
        # (Line 25) PlayWAV("sound\\Protoss\\PROBE\\PPrErr00.WAV");
        # (Line 27) }
        DoActions(PlayWAV("sound\\Protoss\\PROBE\\PPrErr00.WAV"))
        # (Line 28) else if(dx * dx + dy * dy < buildMinRange * buildMinRange) {
    if EUDElseIf()(dx * dx + dy * dy >= buildMinRange * buildMinRange, neg=True):
        # (Line 29) eprintf("건설 위치가 너무 가깝습니다.");
        f_eprintf("건설 위치가 너무 가깝습니다.")
        # (Line 30) PlayWAV("sound\\Protoss\\PROBE\\PPrErr00.WAV");
        # (Line 31) }
        DoActions(PlayWAV("sound\\Protoss\\PROBE\\PPrErr00.WAV"))
        # (Line 32) else {
    if EUDElse()():
        # (Line 33) setloc("buildTarget", targetX, targetY);
        f_setloc("buildTarget", targetX, targetY)
        # (Line 35) const temp = CUnit.from_read(EPD(0x628438));
        temp = CUnit.from_read(EPD(0x628438))
        # (Line 37) if(orderId == 31){
        if EUDIf()(orderId == 31):
            # (Line 38) CreateUnit(1, "Protoss Probe", "buildTarget", player);
            # (Line 39) bwrite_epd(temp + 0x4C/4, 1, 31);
            DoActions(CreateUnit(1, "Protoss Probe", "buildTarget", player))
            f_bwrite_epd(temp + 0x4C // 4, 1, 31)
            # (Line 40) } else {
        if EUDElse()():
            # (Line 41) CreateUnit(1, "Terran SCV", "buildTarget", player);
            # (Line 42) bwrite_epd(temp + 0x4C/4, 1, 30);
            DoActions(CreateUnit(1, "Terran SCV", "buildTarget", player))
            f_bwrite_epd(temp + 0x4C // 4, 1, 30)
            # (Line 43) }
            # (Line 48) wwrite_epd(temp + 0x58/4, 0, targetX);
        EUDEndIf()
        f_wwrite_epd(temp + 0x58 // 4, 0, targetX)
        # (Line 49) wwrite_epd(temp + 0x58/4, 2, targetY);
        f_wwrite_epd(temp + 0x58 // 4, 2, targetY)
        # (Line 51) wwrite_epd(temp + 0x98/4, 0, buildQ);
        f_wwrite_epd(temp + 0x98 // 4, 0, buildQ)
        # (Line 53) tempUnitGroup.add(temp);
        tempUnitGroup.add(temp)
        # (Line 54) }
        # (Line 57) bwrite_epd(unit + 0x4C/4, 1, 3);
    EUDEndIf()
    f_bwrite_epd(unit + 0x4C // 4, 1, 3)
    # (Line 58) bwrite_epd(unit + 0x4C/4, 2, 0);
    f_bwrite_epd(unit + 0x4C // 4, 2, 0)
    # (Line 59) wwrite_epd(unit + 0x98/4, 0, 228);
    f_wwrite_epd(unit + 0x98 // 4, 0, 228)
    # (Line 61) }
