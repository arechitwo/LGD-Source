## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *
from eudplib.core.eudfunc import EUDTraceLog, EUDTracedFunc, EUDTracedTypedFunc, EUDTracedMethod, EUDTracedTypedMethod
from eudplib.epscript.helper import _RELIMP, _TYGV, _TYSV, _TYLV, _CGFW, _ARR, _VARR, _SRET, _SV, _ATTW, _ARRW, _ATTC, _ARRC, _L2V, _LSH, _ALL
# (Line 1) import Systems.chat_manager as chatmgr;
from Systems import chat_manager as chatmgr
# (Line 3) const cityMaps = EUDVArray(128, EUDArray)(py_eval("[EUDArray(128) for _ in range(128)]"));
cityMaps = _CGFW(lambda: [EUDVArray(128, EUDArray)(eval("[EUDArray(128) for _ in range(128)]"))], 1)[0]
# (Line 4) const tempUnitGroup = UnitGroup(1700);
tempUnitGroup = _CGFW(lambda: [UnitGroup(1700)], 1)[0]
# (Line 5) const smallCityGroup = UnitGroup(1700);
smallCityGroup = _CGFW(lambda: [UnitGroup(1700)], 1)[0]
# (Line 8) function getBuildQNRange(epd){
@EUDFunc
def f_getBuildQNRange(epd):
    # (Line 9) var buildMaxRange = 12 * 32;
    buildMaxRange = _TYLV([None], [12 * 32])
    # (Line 10) var buildMinRange = 5 * 32;
    buildMinRange = _TYLV([None], [5 * 32])
    # (Line 11) var buildQ;
    buildQ = EUDVariable()
    # (Line 12) epdswitch(epd + 0x98/4, 0xFF){
    EPDSwitch(epd + 0x98 // 4, 0xFF)
    # (Line 13) case $U("방앗간"):
    _t1 = EUDSwitchCase()
    # (Line 14) buildQ = $U("방앗간");
    if _t1(EncodeUnit("방앗간")):
        buildQ << (EncodeUnit("방앗간"))
        # (Line 15) buildMaxRange = 12 * 32;
        buildMaxRange << (12 * 32)
        # (Line 16) buildMinRange = 5 * 32;
        buildMinRange << (5 * 32)
        # (Line 17) break;
        EUDBreak()
        # (Line 18) case $U("항구"):
    _t2 = EUDSwitchCase()
    # (Line 19) buildQ = $U("항구");
    if _t2(EncodeUnit("항구")):
        buildQ << (EncodeUnit("항구"))
        # (Line 20) buildMaxRange = 32 *32;
        buildMaxRange << (32 * 32)
        # (Line 21) buildMinRange = 0;
        buildMinRange << (0)
        # (Line 22) break;
        EUDBreak()
        # (Line 23) case $U("병영"):
    _t3 = EUDSwitchCase()
    # (Line 24) buildQ = $U("병영");
    if _t3(EncodeUnit("병영")):
        buildQ << (EncodeUnit("병영"))
        # (Line 25) buildMaxRange = 10 * 32;
        buildMaxRange << (10 * 32)
        # (Line 26) buildMinRange = 1 * 32;
        buildMinRange << (1 * 32)
        # (Line 27) break;
        EUDBreak()
        # (Line 28) case $U("소도시"):
    _t4 = EUDSwitchCase()
    # (Line 29) buildQ = $U("소도시");
    if _t4(EncodeUnit("소도시")):
        buildQ << (EncodeUnit("소도시"))
        # (Line 30) buildMaxRange = 15 * 32;
        buildMaxRange << (15 * 32)
        # (Line 31) buildMinRange = 10 * 32;
        buildMinRange << (10 * 32)
        # (Line 32) break;
        EUDBreak()
        # (Line 33) case $U("시장"):
    _t5 = EUDSwitchCase()
    # (Line 34) buildQ = $U("시장");
    if _t5(EncodeUnit("시장")):
        buildQ << (EncodeUnit("시장"))
        # (Line 35) buildMaxRange = 12 * 32;
        buildMaxRange << (12 * 32)
        # (Line 36) buildMinRange = 5 * 32;
        buildMinRange << (5 * 32)
        # (Line 37) break;
        EUDBreak()
        # (Line 38) default:
    # (Line 39) simpleprint("알 수 없는 빌드 명령이 들어온것임");
    if EUDSwitchDefault()():
        f_simpleprint("알 수 없는 빌드 명령이 들어온것임")
        # (Line 40) }
    # (Line 42) return buildQ, buildMaxRange, buildMinRange;
    EUDEndSwitch()
    EUDReturn(buildQ, buildMaxRange, buildMinRange)
    # (Line 43) }
    # (Line 45) function resetBuildOrder(epd){

@EUDFunc
def f_resetBuildOrder(epd):
    # (Line 47) bwrite_epd(epd + 0x4C/4, 1, 3);
    f_bwrite_epd(epd + 0x4C // 4, 1, 3)
    # (Line 48) bwrite_epd(epd + 0x4C/4, 2, 0);
    f_bwrite_epd(epd + 0x4C // 4, 2, 0)
    # (Line 49) wwrite_epd(epd + 0x98/4, 0, 228);
    f_wwrite_epd(epd + 0x98 // 4, 0, 228)
    # (Line 50) }
    # (Line 52) function newCity(unit : CUnit){

@EUDTypedFunc([CUnit])
def f_newCity(unit):
    # (Line 53) const player = unit.owner;
    player = unit.owner
    # (Line 54) const posX = unit.posX;
    posX = unit.posX
    # (Line 55) const posY = unit.posY;
    posY = unit.posY
    # (Line 56) const cityX = posX >> 6;
    cityX = posX >> 6
    # (Line 57) const cityY = posY >> 6;
    cityY = posY >> 6
    # (Line 58) cityMaps[cityX][cityY] = player + 1; // 도시 맵에 플레이어 번호 저장 (0은 빈 공간)
    _ARRW(cityMaps[cityX], cityY) << (player + 1)
    # (Line 59) smallCityGroup.add(unit);
    smallCityGroup.add(unit)
    # (Line 60) }
    # (Line 62) function buildFromCapital(player : TrgPlayer, unit : CUnit){

@EUDTypedFunc([TrgPlayer, CUnit])
def f_buildFromCapital(player, unit):
    # (Line 63) const orderId          = unit.orderID;
    orderId = unit.orderID
    # (Line 65) if (orderId != 31 && orderId != 30) return false;// 건설 명령이 아닐 경우 리턴
    if EUDIf()(EUDSCAnd()(orderId == 31, neg=True)(orderId == 30, neg=True)()):
        EUDReturn(False)
        # (Line 68) const orderState       = unit.orderState;
    EUDEndIf()
    orderState = unit.orderState
    # (Line 69) const posX             = unit.posX;
    posX = unit.posX
    # (Line 70) const posY             = unit.posY;
    posY = unit.posY
    # (Line 71) const targetX          = unit.orderTargetX;
    targetX = unit.orderTargetX
    # (Line 72) const targetY          = unit.orderTargetY;
    targetY = unit.orderTargetY
    # (Line 77) const buildQ, buildMaxRange, buildMinRange = getBuildQNRange(unit);
    buildQ, buildMaxRange, buildMinRange = List2Assignable([f_getBuildQNRange(unit)])
    # (Line 79) const dx = posX - targetX;
    dx = posX - targetX
    # (Line 80) const dy = posY - targetY;
    dy = posY - targetY
    # (Line 81) dx.iabs();
    dx.iabs()
    # (Line 82) dy.iabs();
    dy.iabs()
    # (Line 83) if (dx * dx + dy * dy > buildMaxRange * buildMaxRange) {
    if EUDIf()(dx * dx + dy * dy <= buildMaxRange * buildMaxRange, neg=True):
        # (Line 84) eprintf("건설 위치가 너무 멉니다.");
        f_eprintf("건설 위치가 너무 멉니다.")
        # (Line 85) PlayWAV("sound\\Protoss\\PROBE\\PPrErr00.WAV");
        # (Line 86) resetBuildOrder(unit);
        DoActions(PlayWAV("sound\\Protoss\\PROBE\\PPrErr00.WAV"))
        f_resetBuildOrder(unit)
        # (Line 87) return false;
        EUDReturn(False)
        # (Line 88) }
        # (Line 90) if(dx * dx + dy * dy < buildMinRange * buildMinRange) {
    EUDEndIf()
    if EUDIf()(dx * dx + dy * dy >= buildMinRange * buildMinRange, neg=True):
        # (Line 91) eprintf("건설 위치가 너무 가깝습니다.");
        f_eprintf("건설 위치가 너무 가깝습니다.")
        # (Line 92) PlayWAV("sound\\Protoss\\PROBE\\PPrErr00.WAV");
        # (Line 93) resetBuildOrder(unit);
        DoActions(PlayWAV("sound\\Protoss\\PROBE\\PPrErr00.WAV"))
        f_resetBuildOrder(unit)
        # (Line 94) return false;
        EUDReturn(False)
        # (Line 95) }
        # (Line 97) if(buildQ == 170){//만약 도시일땐 도시끼리의 가까이 있는지도 봐야함
    EUDEndIf()
    if EUDIf()(buildQ == 170):
        # (Line 98) const cityX = targetX >> 6;
        cityX = targetX >> 6
        # (Line 99) const cityY = targetY >> 6;
        cityY = targetY >> 6
        # (Line 100) for(var dx = 0; dx <= 6; dx++) {
        dx_1 = _TYLV([None], [0])
        if EUDWhile()(dx_1 <= 6):
            def _t6():
                dx_1.__iadd__(1)
            # (Line 101) for(var dy = 0; dy <= 6; dy++) {
            dy_1 = _TYLV([None], [0])
            if EUDWhile()(dy_1 <= 6):
                def _t8():
                    dy_1.__iadd__(1)
                # (Line 102) if((dx + dy) <= 3 && (dx+dy) >= 9) continue; // 마름모(맨해튼 거리 3 이내만 검사)
                if EUDIf()(EUDSCAnd()((dx_1 + dy_1) <= 3)((dx_1 + dy_1) >= 9)()):
                    EUDContinue()
                    # (Line 103) const nx = cityX + dx - 3;
                EUDEndIf()
                nx = cityX + dx_1 - 3
                # (Line 104) const ny = cityY + dy - 3;
                ny = cityY + dy_1 - 3
                # (Line 105) if(nx >= 128 || ny >= 128) continue;
                if EUDIf()(EUDSCOr()(nx >= 128)(ny >= 128)()):
                    EUDContinue()
                    # (Line 106) if(cityMaps[nx][ny] != 0) {
                EUDEndIf()
                if EUDIf()(_ARRC(cityMaps[nx], ny) == 0, neg=True):
                    # (Line 107) eprintf("도시가 이미 존재합니다.");
                    f_eprintf("도시가 이미 존재합니다.")
                    # (Line 108) PlayWAV("sound\\Protoss\\PROBE\\PPrErr00.WAV");
                    # (Line 109) resetBuildOrder(unit);
                    DoActions(PlayWAV("sound\\Protoss\\PROBE\\PPrErr00.WAV"))
                    f_resetBuildOrder(unit)
                    # (Line 110) return false;
                    EUDReturn(False)
                    # (Line 111) }
                    # (Line 112) }
                EUDEndIf()
                # (Line 113) }
                EUDSetContinuePoint()
                _t8()
            EUDEndWhile()
            # (Line 114) }
            EUDSetContinuePoint()
            _t6()
        EUDEndWhile()
        # (Line 116) if(true) {
    EUDEndIf()
    if EUDIf()(True):
        # (Line 117) setloc("buildTarget", targetX, targetY);
        f_setloc("buildTarget", targetX, targetY)
        # (Line 119) const temp = CUnit.from_next();
        temp = CUnit.from_next()
        # (Line 121) if(orderId == 31){
        if EUDIf()(orderId == 31):
            # (Line 122) CreateUnit(1, "Protoss Probe", "buildTarget", player);
            # (Line 123) temp.orderID = 31;
            DoActions(CreateUnit(1, "Protoss Probe", "buildTarget", player))
            _ATTW(temp, 'orderID') << (31)
            # (Line 125) } else {
        if EUDElse()():
            # (Line 126) CreateUnit(1, "Terran SCV", "buildTarget", player);
            # (Line 128) temp.orderID = 30;
            DoActions(CreateUnit(1, "Terran SCV", "buildTarget", player))
            _ATTW(temp, 'orderID') << (30)
            # (Line 129) }
            # (Line 133) temp.orderTargetX = targetX;
        EUDEndIf()
        _ATTW(temp, 'orderTargetX') << (targetX)
        # (Line 134) temp.orderTargetY = targetY;
        _ATTW(temp, 'orderTargetY') << (targetY)
        # (Line 135) temp.buildQueue1 = buildQ;
        _ATTW(temp, 'buildQueue1') << (buildQ)
        # (Line 139) tempUnitGroup.add(temp);//캐싱 지울 유닛
        tempUnitGroup.add(temp)
        # (Line 140) resetBuildOrder(unit);
        f_resetBuildOrder(unit)
        # (Line 141) return true;
        EUDReturn(True)
        # (Line 142) }
        # (Line 143) return false;
    EUDEndIf()
    EUDReturn(False)
    # (Line 145) }
    # (Line 147) function transFormCity(){

@EUDFunc
def f_transFormCity():
    # (Line 148) const chat = chatmgr.chatAction_[0];
    chat = chatmgr.chatAction_[0]
    # (Line 149) if(chat == 0) return;
    if EUDIf()(chat == 0):
        EUDReturn()
        # (Line 150) }
    EUDEndIf()
    # (Line 153) function run(){

@EUDFunc
def f_run():
    # (Line 154) transFormCity();
    f_transFormCity()
    # (Line 155) if(Deaths(0, Exactly, 3, 215)){
    if EUDIf()(Deaths(0, Exactly, 3, 215)):
        # (Line 156) CreateUnit(1, 40, "mouse1", 7);
        # (Line 157) }
        DoActions(CreateUnit(1, 40, "mouse1", 7))
        # (Line 158) }
    EUDEndIf()
    # (Line 160) function exit(){

@EUDFunc
def f_exit():
    # (Line 161) foreach(unit : tempUnitGroup.cploop) {
    for unit in tempUnitGroup.cploop:
        # (Line 162) foreach(dead : unit.dying) {}
        for dead in unit.dying:
            # (Line 163) unit.move_cp(0x4C / 4);
            pass

        unit.move_cp(0x4C // 4)
        # (Line 164) if (!DeathsX(CurrentPlayer, Exactly, 31 << 8, 0, 0xFF00) &&
        _t1 = EUDIf()
        # (Line 165) !DeathsX(CurrentPlayer, Exactly, 30 << 8, 0, 0xFF00) &&
        # (Line 166) !DeathsX(CurrentPlayer, Exactly, 33 << 8, 0, 0xFF00)) {
        if _t1(EUDSCAnd()(DeathsX(CurrentPlayer, Exactly, _LSH(31,8), 0, 0xFF00), neg=True)(DeathsX(CurrentPlayer, Exactly, _LSH(30,8), 0, 0xFF00), neg=True)(DeathsX(CurrentPlayer, Exactly, _LSH(33,8), 0, 0xFF00), neg=True)()):
            # (Line 167) unit.move_cp(0x93/4);
            unit.move_cp(0x93 // 4)
            # (Line 168) bwrite_cp(0,3,4);
            f_bwrite_cp(0, 3, 4)
            # (Line 169) unit.move_cp(0x4D/4);
            unit.move_cp(0x4D // 4)
            # (Line 170) bwrite_cp(0,1,0);
            f_bwrite_cp(0, 1, 0)
            # (Line 171) }
            # (Line 172) }
        EUDEndIf()
        # (Line 173) }
